id = serial number (my Libre 2 reads: E0:07:A4:00:04:14:D8:3E, the endiannes needs to be determined because the examples show a flipped ID)

Decrypts 43 blocks of Libre 2 FRAM
- Parameters:
- type: Suppurted sensor type (.libre2, .libreUS14day)
- id: ID/Serial of the sensor. Could be retrieved from NFC as uid.
- info: Sensor info. Retrieved by sending command '0xa1' via NFC.

for i in 0 ..< 43 {
  let input = prepareVariables(id: id, x: UInt16(i), y: getArg(block: i))
  let blockKey = processCrypto(input: input)

  result.append(data[i * 8 + 0] ^ UInt8(truncatingIfNeeded: blockKey[0]))
  result.append(data[i * 8 + 1] ^ UInt8(truncatingIfNeeded: blockKey[0] >> 8))
  result.append(data[i * 8 + 2] ^ UInt8(truncatingIfNeeded: blockKey[1]))
  result.append(data[i * 8 + 3] ^ UInt8(truncatingIfNeeded: blockKey[1] >> 8))
  result.append(data[i * 8 + 4] ^ UInt8(truncatingIfNeeded: blockKey[2]))
  result.append(data[i * 8 + 5] ^ UInt8(truncatingIfNeeded: blockKey[2] >> 8))
  result.append(data[i * 8 + 6] ^ UInt8(truncatingIfNeeded: blockKey[3]))
  result.append(data[i * 8 + 7] ^ UInt8(truncatingIfNeeded: blockKey[3] >> 8))
}

static let key: [UInt16] = [0xA0C5, 0x6860, 0x0000, 0x14C6]

static func prepareVariables(id: [UInt8], x: UInt16, y: UInt16) -> [UInt16] {
  let s1 = UInt16(truncatingIfNeeded: UInt(UInt16(id[5], id[4])) + UInt(x) + UInt(y))
  let s2 = UInt16(truncatingIfNeeded: UInt(UInt16(id[3], id[2])) + UInt(key[2]))
  let s3 = UInt16(truncatingIfNeeded: UInt(UInt16(id[1], id[0])) + UInt(x) * 2)
  let s4 = 0x241a ^ key[3]

  return [s1, s2, s3, s4]
}

static func processCrypto(input: [UInt16]) -> [UInt16] {
  func op(_ value: UInt16) -> UInt16 {
    // We check for last 2 bits and do the xor with specific value if bit is 1
    var res = value >> 2 // Result does not include these last 2 bits
    if value & 1 != 0 { // If last bit is 1
      res = res ^ key[1]
    }
  
    if value & 2 != 0 { // If second last bit is 1
      res = res ^ key[0]
    }
    return res
  }

  let r0 = op(input[0]) ^ input[3]
  let r1 = op(r0) ^ input[2]
  let r2 = op(r1) ^ input[1]
  let r3 = op(r2) ^ input[0]
  let r4 = op(r3)
  let r5 = op(r4 ^ r0)
  let r6 = op(r5 ^ r1)
  let r7 = op(r6 ^ r2)

  let f1 = r0 ^ r4
  let f2 = r1 ^ r5
  let f3 = r2 ^ r6
  let f4 = r3 ^ r7
  
  return [f4, f3, f2, f1];
}

static func usefulFunction(id: [UInt8], x: UInt16, y: UInt16) -> [UInt8] {
  let blockKey = processCrypto(input: prepareVariables(id: id, x: x, y: y))
  let low = blockKey[0]
  let high = blockKey[1]

  let r1 = low ^ 0x4163
  let r2 = high ^ 0x4344

  return [
    UInt8(truncatingIfNeeded: r1),
    UInt8(truncatingIfNeeded: r1 >> 8),
    UInt8(truncatingIfNeeded: r2),
    UInt8(truncatingIfNeeded: r2 >> 8)
    ]
 }

